Program = _{ SOI ~ Expr* ~ EOI }

WHITESPACE = _{ " " | "\t" | NEWLINE }

COMMENT = _{ SingleLineComment | MultilineComment }
SingleLineComment = _{ "//" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI) }
MultilineComment = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }

Expr = { "(" ~ Term+ ~ ")" }

Term = { Expr | Number | String | Sequence | Symbol }

Number = ${ HexNum | BinNum | FloatNum | DecNum }

HexNum = @{ "0x" ~ ASCII_HEX_DIGIT+ }
BinNum = @{ "0b" ~ ("0" | "1")+ }
FloatNum = @{ ("-"? ~ (ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT*) | ("." ~ ASCII_DIGIT+)) }
DecNum = @{ "-"? ~ ASCII_DIGIT+ }

String = @{ QUOTATION_MARK ~ (("\\" ~ QUOTATION_MARK) | (!QUOTATION_MARK ~ ANY))* ~ QUOTATION_MARK }

Sequence = { "[" ~ Term* ~ "]" }

Symbol = @{ (!SymbolBannedChars ~ ANY)+ }
SymbolBannedChars = _{ WHITESPACE | QUOTATION_MARK | "(" | ")" | "[" | "]" }

/*
 * Whitespace = java.lang.Character.isWhiteSpace(char ch)
 * SpecialReaderMacro = [`~@]
 * String = "<chars>" ->> special chars: \\ \b \f \n \r \t \u[[:number:]]{4} - unicode
 * TillEndOfLineComment = ;
 * Var = '<symbol> == (var symbol)
 * Deref = @<symbol> == (deref symbol)
 * Meta = ^{:metakey1 :metavalue1, :k1 true, :tag String} == ^{:metakey1 :metavalue1} ^:k1 ^String // also possible
 * List = (<items>)
 * Vector = [<items>]
 * HashMap = {<items>}
 * Char = \.{1} ->char , specials: \backspace \formfeed \newline \return \space \tab \u[[:number:]]{4} - unicode, \o[[:number:]]{3} - octal
 * AnonymousFucntionArgument = %1, %2, ..., %9 + %&  ->> see #() reader macro
 * DispatchReaderMacro = # ->> see below (prepend '#' before the form)
 *     #^{:metakey1 :metavalue1, :k1 true, :tag String} == #^{:metakey1 :metavalue1} #^:k1 #^String
 *     ##<symbolic float value> ->> ##Inf, ##-Inf, ##NaN
 *     #'<symbol> == (var symbol)
 *     #"<regex>"
 *     #(apply abc %1 %3 %2 %&) == (fn [x y z & args] (apply abc x z y args)) // WARNING: CAN'T DOUBLE NEST -> ERROR!
 *     #{<hash-set>} // IF NOT DISTINCT ITEMS, FAIL!
 *     #=(println "Hello, world!") ->> evaluates instantly, without macroexpanding and interpreting symbols
 *     #!<comment till end of line>
 *     #<<unreadable form>> ->> ERROR
 *     #_(this form will be discarded) #_123 #_"abc" #_hello #_#{:uwu :nice} // all of these are forms
 *     #?(:clj java.lang.Math.cos, :cljs js/math.cos) ->> conditional reader depending on platform
 *     #:Hello{:foo 1 :bar 2} == {:Hello/foo 1 :Hello/bar 2} // namespace map reader
 *          #::{:foo 1 :bar 2} == {:project.current.namespace/foo 1 :project.current.namespace 2}
 *
 * Unquote = ~ (see below)
 * SyntaxQuote = `
 *     useful in macros
 *     (let [x 123, y 456, z ["hello" :world ()], w (baz :foo 404)]
 *       `(bar x ~y ~@z ~@w))
 *     // 2nd line expands to:
 *     (quote (bar current.namespace/x 123 "hello" :world () baz :foo 404))
 *
 *     `(let [a 345, b 432, c# 748, d# 45, c 415]
 *        (~a ~b c# d# ~c))
 *     // may expand to something like this . uses '#' as unique symbols, if not used in SyntaxQuote, wrong syntax!!!
 *     (let [a 345, b 432, __c__auto__7402__ 748, __c__auto__7407__ 45, c 415]
 *       (~a ~b __c__auto__7402__ __c__auto__7407__ ~c))
 *
 *
*/